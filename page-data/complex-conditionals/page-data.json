{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/complex-conditionals","result":{"data":{"post":{"slug":"/complex-conditionals","title":"Complex conditionals","date":"13.03.2019","tags":null,"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"post\",\n  \"title\": \"Complex conditionals\",\n  \"categories\": \"article, code coverage, testing\",\n  \"date\": \"2019-03-13T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The other day we dealt with code coverage and gnarly conditionals. I promised to offer a way to be able to test them properly.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"THERE IS NONE.\")), mdx(\"p\", null, \"Ha, what a bad joke. But the real answer might not be better, depending on your point of view.\\nWhat you have to do is create a table.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ruby\"\n  }, \"(A || B) && C\\n\")), mdx(\"p\", null, \"This is our conditional.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ruby\"\n  }, \"| m | A | B | C | RESULT |\\n----------------------\\n| 0 | T | T | T |    T   |\\n| 1 | T | F | T |    T   | x\\n| 2 | F | F | T |    F   | x\\n| 3 | F | T | T |    T   | x\\n| 4 | T | T | F |    F   |\\n| 5 | T | F | F |    F   | x\\n| 6 | F | T | F |    F   |\\n| 7 | F | F | F |    F   |\\n\\n# m is the test case\\n# A, B, C are the atomic parts of the conditional\\n# RESULT is the result of the evaluation of the conditional\\n\")), mdx(\"p\", null, \"For three terms in a conditional, you can have 8 different cases (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2^3\"), \"). You don't need to test every case. You have to find those cases where switching one term (A, B or C) changes the RESULT. You take those cases and write tests for them. You can ignore the rest as they don't bring you any new information. For our example these could be the test cases \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1, 2, 3, 4\"), \". I marked them with an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \",\"), mdx(\"p\", null, \"The general rule of thumb is that you can solve this with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n + 1\"), \" test cases where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" is the number of terms.\"), mdx(\"p\", null, \"This technique is called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Modified Condition/Decision Coverage\"), \" or short \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MC/DC\"), \". I like this name, it's easy to remember \\uD83E\\uDD18.\"), mdx(\"p\", null, \"It gets harder to do, when one term of the conditional is used more than once (coupled). Another thing to take note of is that depending on the decision statement in the code, it may not be possible to vary the value of the coupled term such that it alone causes the decision outcome to change. You can deal with this by only testing uncoupled atomic decisions. Or you analyse every case where coupling occurs one-by-one. Then you know which ones to use.\"), mdx(\"p\", null, \"You'll have to do this in the aerospace software industry or where you deal with safety-critical systems.\"), mdx(\"p\", null, \"If you read this far: Congratulations. This is one of the more in-depth topics of testing software. You deserve a \\uD83D\\uDC4F for learning about these things!\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"The other day we dealt with code coverage and gnarly conditionals. I promised to offer a way to be able to test them properly. THERE IS NONEâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/complex-conditionals","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["2744905544","3090400250","318001574"]}
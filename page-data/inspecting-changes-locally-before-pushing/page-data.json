{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/inspecting-changes-locally-before-pushing","result":{"data":{"post":{"__typename":"MdxPost","slug":"/inspecting-changes-locally-before-pushing","title":"Inspecting changes locally before pushing","date":"21.03.2019","tags":null,"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"post\",\n  \"title\": \"Inspecting changes locally before pushing\",\n  \"categories\": \"article\",\n  \"date\": \"2019-03-21 16:24:00 +0200\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you work on your branch you run into the situation that you would like to push your changes to the remote repository. CI will then pick up your changes and run the linting and code quality checks on it. Afterwards, you will see whether you improved the quality. But perhaps there are some new violations that crept into the code? Happens to all of us!\"), mdx(\"p\", null, \"I usually like to see and check if any new issues might come up on CI. This lets me improve them before I push.\\nThe checks I run locally depend on the kind of work that I do. Lately that's a lot of Ruby on Rails again \\u2014 which is great. I love that framework and the language.\\nTo grade my code, I use Rubocop, Reek and Flay. If you run their respective commands on your repository, they will check the whole code base. This might be ok, if you didn't have any issues before. Since I join teams, these days, that work on legacy projects it is rare that there are no problems with the code. If I run the commands just so, I will get a long list and couldn't possibly see the issues that I introduced through my changes. Lucikly, there is Git and some \\\"command line foo\\\" that can help us here:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git fetch && git diff-tree -r --no-commit-id --name-only master@\\\\{u\\\\} head | xargs ls -1 2>/dev/null | grep '\\\\.rb$' | xargs rubocop\")), mdx(\"p\", null, \"This command will fetch the current state from the remote and diff your branch/changes to master branch. It then runs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rubocop\"), \" on these changes.\\nIn my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"~/.aliases.local\"), \" file I added three lines for all three linters.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"# Code Quality\\nalias rubocop-changes=\\\"git fetch && git diff-tree -r --no-commit-id --name-only master@\\\\{u\\\\} head | xargs ls -1 2>/dev/null | grep '\\\\.rb$' | xargs rubocop\\\"\\nalias reek-changes=\\\"git fetch && git diff-tree -r --no-commit-id --name-only master@\\\\{u\\\\} head | xargs ls -1 2>/dev/null | grep '\\\\.rb$' | xargs reek\\\"\\nalias flay-changes=\\\"git fetch && git diff-tree -r --no-commit-id --name-only master@\\\\{u\\\\} head | xargs ls -1 2>/dev/null | grep '\\\\.rb$' | xargs flay\\\"\\n\\n\")), mdx(\"p\", null, \"I am still working on a way to just call one command and have all thee commands run. That doesn't yet work. Probably because of exit-code reasons, when one linter finds issues.\"), mdx(\"p\", null, \"These simple commands offer a convenient way to find local issues and correct them before pushing to CI.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"If you work on your branch you run into the situation that you would like to push your changes to the remote repository. CI will then pickâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/inspecting-changes-locally-before-pushing","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}
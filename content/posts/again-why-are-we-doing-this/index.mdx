---
layout: post
title: "Again, why are we doing this?"
categories: "newsletter"
date: 2018-09-14 15:00:00 +0200
---

Imagine you have a team member that always criticises your work. You make commit after commit and put your best effort forth, you try to find the best names for variables and methods. You check your code using tools like RuboCop and Linters. Yet in every pull request, he asks you whether you considered refactoring objects. Things like extracting some logic out of a class, introducing view models and repository objects and sometimes even _crazy_ stuff like domain driven design ideas. Why can't he leave you alone?

I tell you why: Because the fundamentals matter. They make the difference between software projects where things go smoothly and projects that just fail.
<!--more-->
> IT failures can also stunt economic growth and quality of life. Back in **1981**, the U.S. Federal Aviation Administration began looking into upgrading its antiquated air-traffic-control system, but the effort to build a replacement soon became riddled with problems. By **1994**, when the agency finally gave up on the project, **the predicted cost had tripled, more than $2.6 billion had been spent**, and the expected delivery date had slipped by several years. Every airplane passenger who is delayed because of gridlocked skyways still feels this cancellation; **the cumulative economic impact of all those delays on just the U.S. airlines** (never mind the passengers) **approaches $50 billion**.

Source: [https://spectrum.ieee.org/computing/software/why-software-fails](#)
_(Emphasis by me)_

That's $50 billion that could have been spent in another way. Now I cannot know what kinds of problems actually were present in this project. There are many different problems an IT project can suffer from. Projects of this size that fail, usually suffer from many of them at once.

Software development fundamentals are a big part. And these are a part you can control. So take every chance you get to improve at your craft.
Here are some ideas for different skill levels.

For a junior/beginner:
- Design styles like object-oriented design and structured design
- Design patterns for organizing code
- Foundational design concepts like encapsulation, information hiding, dependency injection, modularity, composition vs. inheritance

For advanced / intermediates / professionals:
- approaches to memory management
- performance optimizations
- database design (advanced usage of unique attributes of your db)
- standards about internationalization
- UX and UI and how you as a developer can integrate that knowledge into your products

For seniors / experienced software engineers:
- Specifics and unique approaches to the domain you are working in (health industry, travel industry, manufacturing â€¦)
- architectural designs patterns (layers, ports and adapters, SOA, multi-tier, publish-subscribe etc.) to be able to optimize for different qualities attributes like cost, performance, stability, security, maintainability etc.

Linting your code and making sure the code meets minimum standards is one step. And it's a vital step. But the road is long and stony. (Sorry I had to write that ðŸ˜‡)

If you need assistance with any of these topics, reply to this letter and we figure it out.

Yours,
Holger
